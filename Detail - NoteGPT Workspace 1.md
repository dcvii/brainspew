---
title: "Making Simple Software"
source: "https://notegpt.io/workspace/detail/czzAVuVz7u4"
author:
published:
created: 2025-02-27
description:
tags:
  - "clippings"
---
Why Can't We Make Simple Software? - Peter van Hardenberg

![](https://nc-cdn.oss-us-west-1.aliyuncs.com/notegpt/my_notes_images/75451b258546ccd8ef3a3bb64b86ca7e.png)

you are many things and I can't explain it properly so you should introduce yourself but yeah your microphone's right here y press hard for the next slide backwards and a pointer if you need it great thanks thank you so much hi everyone um I'm Peter I'm going to kind of take things in a bit more of a philosophical kind of Direction um you know I work for a research lab these days so that's kind of my uh tendency um the lab is called Inc and switch uh we are interested in carrying on kind of the work of like engelbart and lick lier

and Alan Kay and these people we interested in how computers can augment human intelligence and uh you know that's very high futin it's a lot of fun we get to dig into all kinds of weird corners of software and experimental interfaces and so on but before that I have written a lot of production software so I'm not just speaking to you from kind of an ivory Tower perspective I was one of the early employees at a platform as a service company uh called Heroku I've run a lot of postrest databases I've

worked in game development as well I've built titles for DS and GBA I worked on this one teenage Zombies Invasion of the alien brain thingies for a Victoria BC game company and I've worked on desktop software like uh Songbird which was a crossplatform media player that lost fairly decisively um and besides that I've also uh worked in uh research um spending some time uh on for example this ship here this for Wilford laor it's a Canadian Arctic uh research Icebreaker so I spent some time in the Arctic and

that actually helps inform my perspective on things too but we'll come back to that so I want to start by kind of saying hold on a sec before we get into kind of talking about why we can't make simple software we should probably Define our terms a little bit and talk about what complexity actually is so the first thing I want to clarify is that complexity is not difficulty right just because something is hard doesn't mean it's complicated like the ideas of calculus might be very difficult to internalize but they're

actually very simple and elegant and I also want to draw a distinction between something being complex or just being kind of big a box of Lego is not necessarily a complicated thing though you can make a lot of things with it complexity occurs when your systems interact with each other okay and when it takes a lot to uh get things done because of that and more specifically I think the problem with complexity is that your systems can become unreasonable and when I say unreasonable I don't mean in kind of like a sort of

colloquial sense what I mean is that you literally cannot reason about them you don't have the ability to predict what's going to happen and a lot of the time that's a problem because you got work to do and the thing is crashing and you don't know why but a complex system can also be generative and surprising if you harness that complexity in positive Ways last before we get into it I want to make just a very small uh detail point for the uh more pedantic in the audience some people draw a uh very

specific difference between uh complex systems from sort of chaos math and like emerging complexity we'll talk a little bit about that H as distinguished from complicated systems where you have a lot of just kind of mess I'm kind kind of going to float back and forth across both of these without a lot of Distinction because I think in this context either one can cause similar effects okay so we're going to begin with a non-comprehensive look at complexity and more specifically we're going to kind of like pick some cherry

pick some examples sort of from fake industrial sort of scenarios where you can begin with something simple and end up with something complicated so I'm going to start with like the most basic of all reasons why your software gets complicated and that's you know the first version of your code you just write the happy path everything's glorious and and software can be really simple when it lives in an idealized world and everything is fine and so you know here's like a really simple imaginary you know pseudo code web thing

great we got a get request to our application you know we're going to go fetch something from the database and say hello there this is a Hello World app of web apps server apps great it works fine you know if user 12 is me and user 10 is my friend KO and user fu is wait what ah right we got to validate the input okay so we'll validate the request now okay so we're validating the request and and that's good and oh geez I'm not really handling it if we don't validate the request and wait do I have

to do this on every request I guess I have to do this on every request and am I doing it the same way on every request in fact this exact pattern of validating user input and checking your arguments can lead to something that uh bratus and Patterson call shotgun parsing and shotgun parsing is kind of the idea that you know you're parsing your input but it's like someone's taken a shotgun to your code base because it's just blown through the whole code base and it can lead to very serious security

vulnerabilities because you might carefully check an input in one place but not in another and a great talk from brwon 2012 about this so of course you know now we're going to be a little more careful so we're going to also you know if the database is down we don't want to send a 500 we're going to fail elegantly and as you go the more of these cases that you have to handle and the better the quality of your code is right the more conservative defensive thorough that you are like at this point now like the the

actual logic of this method is beginning to dis disappear into all the edge case handling right we're we're well off the happy path now and so you know you can clean this up a little bit so for Imagine here in this case that you know we have a slightly uh better set of libraries more thoroughly written set of libraries we've moved the complexity down out of this method and we're sort of saying like well the database won't throw an exception right because exceptions are ugly and kind of subtle to handle well it'll just it'll return

null if it can't do the job for whatever reason and we're going to say well we'll you know there's like a good type system that's handling parsing the input args before they get to us so you know we can we don't have to worry about that anymore and the value of well-written uh libraries and languages type systems and so on is that they can really simplify your code make it less complex by preventing you from have to carry around all of this mental state everywhere that you go and you know kind of my observation

of this world is that like vigilance is not a strategy like we talk earlier about how you know if a system fails it's not oh the blameless postmortem it's not that the the developer failed it's that the system failed you know if you have security vulnerabilities in your code because you didn't handle input the answer isn't to berate yourself for not handling the input you know it's to step back to level up and say like well hold on why do I have to do this manually every time so so to strategically you want to

minimize the scope of failures and and kind of design them out of your system and one way to do that is have a type system so you don't you know forget to check your nulls there are other approaches I don't think this is universally true but it's one way okay so let's talk about scale you know we all know as an array gets bigger you can have an O of n log n kind of sort algorithm great okay well let's you know scale's easy right so let's just imagine an admin panel for a web application you list your users looks kind of like this

go to your database select all the users and then in your front end just show them all perfect easy it's fine you've only got 10 users who cares okay well now we're at 10 to the four okay you've got a thousand users or so okay well okay we can't just render all that on one screen okay well uh we're going to use one of those offset SQL things right we know about this and then we're going to need pagination I guess and you got to click through okay yeah sure we can still do this this is fine yeah you don't want to request all that

it's pain to scroll through okay well now we're 10 to the six users we got a million actually that offset thing that's a problem if you have a lot of users because in order to generate you know page 8850 it actually selects all of those rows and Scrolls through them and just takes all of those results and just Chucks them on the floor until it gets the ones that you asked about and actually now even though nothing has changed about our problem statement like not only are the performance characteristics of the system starting

to change and the user interface is starting to change but the the way that we interact with the problem is changing too because if you've got a million users the way to find a user is not to just like keep clicking next until you find them one page after oh page 350 okay I'm on the J's Okay click forward to change the query AR to force you we've all done these kinds of things when the tools didn't keep up with our admin systems but like the point I'm trying to make here is that you know once you start to reach like a 100

million users you know it's not even the same kind of problem anymore right the complexity that snuck in here is now that we have different responsibilities there are ethical there are legal there are policy responsibilities you probably have a team of people at your organization who are responsible for dealing with abuse some of these people are terrible and you want them off your platform and you can't find them right like it's a different thing and it's complicated because the environment has

changed as much as anything else so everything changes when your scale changes it's not just like an algorithmic thing it's also the kinds of things that you're doing change and like in general my advice to someone who's built a lot of high-scale production systems through many orders of magnitude is that it's as harmful to build for the system of the future as it is to build an insufficient system for the present you know if you build the tools for 100 million users when you have a hundred users they're going to be completely

unusable too and you're going to waste so much time trying to solve problems you don't have yet that you're going to miss out on all the benefits of being able to just look at all your users and see who they are and talk to them right so you need to be scale appropriate and kind of be looking ahead another way software can get complicated is with leaky abstractions and so here we have a platform that's a little bit skewed um and so complexity can kind of Bubble Up from under the water line through these imperfect

extractions abstractions this is how you copy a string it's a nice handmade lowlevel this is an exerp from carigan and Richie 1988 second edition the programming language and this book was such a revelation for me like how it showed me the way colonel uh functions were really implemented no I'm just kidding they're not really implemented like this and they say here that this is how you know a c programmer would prefer to write string copy the C programmer in question has never forgotten to null terminate a

string I see um but this is how string copy is actually implemented as of 2022 for Alpha in uh in Linux and actually this isn't how string copy is implemented this is like one page of assembler uh there's like 300 lines of assembly and really importantly and and intriguingly although the interface Remains the Same modern CPU architectures have so many more constraints around memory alignment and everything else that although the interface is preserved you can pass any pointers in and get values back the kind

of performance characteristics of like doing an unaligned versus an aligned string copy will be dramatically different and so complexity here right like I think we can kind of call this a win right like we've got this superpowered computer under the hood now but it still kind of feels like that old galap they were running in 1988 you know and like that's cool that that it works but in a sense this API that's so simple is actually undermining the value of the system and there's a lot of magic happening to kind of hide this and so I

feel very mixed about this because on the one hand you know it's sort of like SQL databases where like you can add an IND and change nothing else and things get faster but there's like a really important subtle like lie that's being told here but maybe this is good and maybe it's bad this is like a value judgment kind of question and whether you understand this is happening could be completely irrelevant or it could be the difference between the success and failure of a project okay so these are kind of like

technical complexities that come in I want to talk about other sources of complexity different kinds of complexity and one really big source of complexity in my projects maybe your smarter than me and that's cool uh but it's when you have a gap between the problem you think you have or the problem you used to have and the problem you have right now and again we're going to use a toy example to illustrate this so you've got a users table just same app as before and you know your users there's a bunch of

fields you got a first name and a last name and how do you get the first name and the last name it's easy guys you just split on a space as a van hardenberg uh you can see how this might get you in trouble and in fact on my California driver's license it said that my middle name was van for many years and the problem here is that the model that you have for the problem doesn't actually map the problem domain successfully so what do you what do you do right and there are lots of things you can do you can rewrite from scratch

you can patch around it and actually just as an aside for everybody in the room the w3c has a wonderful um essay about personal names around the world and just you know if you take one like little thing from this talk um don't use first name and last name don't use family name people's family names aren't accurate some people have them and others don't uh what you do is you have one field that is you know what is the full name and then the other one is if you need it what should we call you um it's like a much better

model um also Unicode I know that's its own set of complexity but uh and so you know there's only so many things you can do when you have this problem right and like I had a really specific concrete example of this in a distributed system recently where like I had a mental model of how the system behaved and my tests demonstrated that it behaved that way and then in my production environment it behaved completely differently because of behaviors that were not modeled by my understanding of the problem and this is part of why

distributed systems are so prone to this is because there's so many new free variables and and like articulation points where things can be fast or slow or where they can fail or you know arrive out of order and all these kinds of things and so when you have these kinds of model reality gaps you have to bridge them somehow and so what can you do well you can fix the problem you can improve your understanding and rewrite everything and like when you can do that it's probably best you can't really always do that

though and more to the point you may still not actually you could see the problem but you may still not actually understand the solution right and so what can you do well you can hack around it right like I've put van hardenberg into a lot of text boxes without a space in it and you know where the first letter is capitalized and the H is lowercase and that's not how I spell my name but it is how a lot of systems spell my name you know or you can ignore the problem right like maybe it's fine and like genuinely it could be fine for

your use case you're just like well I guess you know that Peter guy can suck it he'll deal with having his name spelled wrong and I do you know it's these are options that you have and there's like a great you know like meme series out there on the internet lies programmers believe about pretty much anything like all time zones are 1 hour apart uh half an hour later in Newan land and so I think this is a this is a very fundamental source of complexity but where things get really bad is when your

problems start to multiply off each other and this of course is you know where you have kind of like compound interest on complexity so what happens if your problems um dimensionalize against each other so again imagine this web application you've got a bunch of different browsers to support you've got a bunch of different runtime environments to support different screen sizes Network speeds different Os or browser versions and so if you want to actually understand what's happening you know all of these things multiply

against each other right and so you don't just have one runtime environment you might have one codebase but you have lots of different contexts so how can you know that you actually have correct functioning code because you know the old joke about Docker like well it worked on my computer well I guess we'll ship your computer well even that doesn't really work because once you get out into the real world there's different memory you know contexts or you're up against different loads or whatever else right you don't actually

control the whole environment and so this is what really starts to kill you with complexity right and it's where all of those smaller inconsistencies play off each other to create an unknowables like you don't use the native apis because God help you if you're trying to like figure out how to map all of these totally different environments down to one consistent thing and like one solution here is just to only have one thing as best you can and to minimize the difference between those environments and that's why you see sort

of like ostensibly lazy electron apps from big companies because even worse than having to support all these different things is having to coordinate all the different people and teams to try and build features right and we've all many of us have been there right like if you have an iOS and an Android team like how do you get them to ship the same feuture in the same quarter right it's tough it's tough okay so I hope I've convinced you now um that complexity is like a a complex problem itself and that it manifests in a lot of

different ways so we're going to change gears a little bit and talk about seat belts and more specifically why seat belts don't save lives and I haven't asked risk here because this is a little bit of a controversial um research topic um but the sort of upshot of this is that in at least some studies they found that after seat belts became mandatory in cars uh people still died on the roads at similar rates and that was really surprising because like you know seat bels are are a good idea like they keep you safer in the car

and so somebody proposed this idea uh called risk homeostasis the idea behind risk homeostasis is that actually we die at a rate on the road related to how much risk we're willing to take and so if you now have a seat belt and you're driving a car that's safer you're going to go a little faster and you're going to take the corners a little tighter because you feel better right so the the issue with making people safer was that they then took on more risky Behavior conserving their total risk tolerance and so I

think we see a similar thing in software right we I call this complexity homeostasis which is to say that if you have kind of a system that's evolving over time you know everything's fine we're going along life is good and then we add some more things and you know we're still happy and then oh oh yeah now it's I don't like it anymore it's not good it feels bad now it's time for that rewrite that we were hearing about right it's time to bring things back ah okay now we can go back to making things complicated again

and so this is kind of like a set point so homeostasis is the process where or it's any process where you sort of maintain a set point and it's commonly used to talk also about how our bodies regulate temperature but I think our organizations regulate complexity right and so all of us have different intuitions and when people talk about wanting things to be simple there's like an aesthetic preference here and different people perceive that and pursue that differently and like Deen's you know quest for just the right number of op

codes that we heard about yesterday is a great example where like in a certain sense you know the correct number of op codes is one and you could do that if you really wanted to but then you've got kind of like the CIS you know model where actually the correct number is hundreds because you're maintaining backwards compatibility and anything that can squeeze you you know either better numbers out of a bench Park Benchmark or more CPU sales is is acceptable and so you know how you perceive what constitutes complexity or

how much complexity you're willing to tolerate is an individual or an organizational decision and you know some things can actually move that up like I have abandoned projects because they got complicated and annoying to work on but like some people might just tolerate that and not perceive it I've worked with some brilliant people who write the most complicated insane convoluted code from my perspective but when I sort of go to them I'm like this is so complicated and weird why did you do it this way they don't see it because

they're just much smarter than me they're they're able to hold that complexity in their head comfortably and so for them it doesn't feel that way another way a system can become more complicated if it's worth a lot of money right because like you can just hire another poor Schmo to sling Java into the code base I mean has anybody here worked on an EA Sports title yeah I'm so sorry I have heard some things man and it ships every year on on Deadline without fail right like that's not an environment that leads to like healthy

refactoring or or reduction of complexity but you know what it makes a boatload of money and so they'll hire people to work on it because they can afford to and you'll work on it because they'll pay you enough because they know they know right and so part of this as well is that also if you just have more people working on things you know you can tolerate more complexity I can hold part of it in my head and you can hold part of it your head and I kind of want to distinguish like there's sort of the

breadth of complexity and if you have a well- factored system you can decompose the complexity either into layers or or modules right like each individual Lego brick is simple but you can build very complicated things from it right and so that's sort of the system complexity versus the component complexity CSS is incredibly complicated and by that what I mean it's complex you can't tell from looking at one rule what it will manifest as in a final document so okay well we can just solve this problem with better tools right

well no because as we've talked about we you know we have this homeostasis point that we fall towards over time and we can choose where to set it but we do move towards it and you know the research on this actually goes all the way back to like the 1860s this is uh Jeff's Paradox which was like why did coal consumption not decrease when engines became more efficient the answer is people did more work right and so I feel very much that this is sort of the inevitable conclusion we have to draw from looking at the problem which is

that the degree of complexity of a system is tied to who we are and what we're doing over time right and so when we buy back some complexity by using better tools or by picking a simpler environment we're going to spend that out again eventually okay so let's talk a little bit about some theories of complexity because you know this I'm from a research lab and I like to like read papers so this is not a new this is not a new problem uh have have people heard of \[Laughter\] \[Applause\] cost and be problematic is worth

thinking about in fact people have been looking at this and thinking about it since the 1980s this is uh mayor liman in 1980s uh i e volume 68 so like this is not a new domain and so even back then this this Edition was from 1980 the first paper published was in 1974 on these laws of software engineering we're not going to read these like super close there it's more that I want you to realize that like this kind of recognition that systems grow to meet growing needs if they're successful is not a new idea it's a

common problem and whether you're working you know in building tools or languages you know you might start with an elegant and simple thing but as a system has more demands on it it responds by adding right that's that's a very common and it's a reasonable consequence and if you don't do those things the thing will often sort of starve and die um one great paper if you haven't read it yet on this sort of topic is out of the tarpit by Mosley this is from 06 and uh this paper differentiates between

what is like accidentally complex versus essentially complex right so like essential complexity is like the irreducible like non- illimitable part of your system you know if you are trying to model certain physical processes like you know smoke or fire like the physics part where you're actually doing the work you can't get rid of that you don't want to get rid of that that's what you're here for right but The Accidental complexity is all that other stuff like oh God we got to compile this so it works on like Windows

11 has changed the ABI for this DL we like all that stuff where you you know we heard about deine hoisting the um uh phone up the uh the Mast to download 11 gigs of something right that's mostly accidental complexity for our purposes and so it helps as you're working and thinking about complexity to to think about where you're spending that budget and whether it's whether you're being deliberate in terms of how you're adopting complexity the other thing I want to uh refer to is this great um this great

essay from the Berkeley DB team in the architecture of Open Source and honestly you I highly recommend reading this if you just like software engineering the architecture of Open Source software is is a a cool series and basically what they do is interview open source communities about their software and have them write essays about what they've done and then they publish and share those but I think this Berkeley DB chapter in particular is exceptional and I I think about this all the time which

is that software architecture degrades with changes made to software right so you might have the most elegant brilliant carefully planned system in the world but it does not exist at a single point in time in a vacuum and as new demands come along this architecture will Decay and so requires a constant Shoring up and when you have big interfaces that you've invested heavily in and they're straining it can be extremely expensive to change them I also just love this this is a little more handmade specific kind of

vibe the Excel team motto at least according to Joel spolski is find your dependencies and eliminate them uh I have been told on reasonably good authority that Excel uh actually is built with its own C compiler that they they didn't even want to rely on other teams within Microsoft and you know to the degree where they've built their own compilers I'm not saying you necessarily should do that I'm not saying you necessarily shouldn't you got to think about how you're spending your budget and the last kind of point I want

to make sort of on this theme is again that complexity isn't necessarily bad right like complexity can lead to all kinds of like wonderful emergent properties right you the Legend of Zelda um you know breath of the Wild it has had so such a wonderful Community grow up around it precisely because they managed to tame complexity with their chemistry engine so there's a lot of emergent gameplay properties and experiences that come out of interactions complex interactions between systems but the systems are

factored in a way that enables and empowers this um and of course if you're a Rog likee fan you know people have been doing this forever there okay so how well now what you know we we've we have now looked at complexity I've told you you can't get rid of it so we're just going to have to live with it and you know better tools won't save us so how are we going to spend this this complexity budget that we have I mean you know one approach is you just put your head down and you work away and and pretend it's not a problem

and you know that that's a pretty common solution to all of our problems in life so we could do that but I'm going to maybe try and propose a few ways we can cut the gordian knot here and so um you know the the story of the gordian knot was that there was this sort of um this Ox cart with a really complicated knot on the the handle and people were like oh whoever whoever unties this notot will rule all of Asia and many people had come and then Alexander the Great came along and depending on the version

of the story you hear he just like he like okay cool and he cut it with a knife right and so instead of solving the problem by like trying to be really smart or work really hard like can we just cheat and change the rules like I think that's a better approach so one approach is to do what folks here like to do is just start over you know you can't actually get rid of this problem but you can reset the clock on it right just build a new one start from the beginning everything's easy in the beginning it's only when you have

users and features that you have complexity so like you know make a new programming language start a new VM it's good you can't really change this like long run pressure but like genuinely you can reset the clock and I think that's part of why things like Excel are popular and successful is they don't have package managers right like every time you make a new Excel document it's a brand new universe you know with none none of the misery or mistakes that you made before it's like the Forgiveness of

the blank page you know that's and there's something to that um I went to a talk by John Romero uh at strange Loop not that long ago and he talked about how ID software had been making these like shovelware games for as contractors or the the ID software team him and him and uh Romero and carac had been making these sort of shovelware games and their attitude was like well you should just always start from scratch you get really good at it you can be really fast and each time you do a little bit better than the one before

and we do I think do better I like I'm not I I love learning new languages and building new ecosystems and I think a big part of the reason why they're successful is because when you have a new language you do have the opportunity to like clear away um like the standard library and also just the ecosystem of ideas and people and sort of start from a fresh starting point now this won't cure complexity in the long run but you know it can get better right at least in the midterm and we can get further so I

think you know that's pretty cool and it's also pretty fun so like I'm I'm all for that please please do more of that and to some extent it's sort of like you know it feels like we live in these uh unbreakable regimes where like Unity you know rules or where like the big companies Google and Microsoft and everybody rules but that's the kind of thing that's true until it isn't and there's this lovely quote from Ursula lwin about capitalism which is sort of you know the generalization of these problems you know capitalism was itself

an invention and um you know I'll just read it we live in capitalism M its power seems inescapable so did the divine right of kings and any human power can be res resisted and changed by human beings right so we we should not doubt that the environment can be changed the environment was created it will be changed we don't know how or when but it is inevitable okay so you can start over Revolution burn it down or you know just do l do less with less uh do I have my play date does do people have these hases

anybody got a play date yeah this is great it's black and white it it's there's only one platform it's small it comes in one color it only has one color black or white depending on how you think about it doesn't have a lot of buttons doesn't have much RAM doesn't really have any there's a little bit of networking and there's only one Hardware platform so you don't have to worry about compatibility problems is there there is the emulator which behaves differently and due to like sourcing problems they had to get a different

micro controller but it transpiles natively they're doing a really good job anyway it's a heck of a lot simpler than building for PS5 you know Xbox PC switch 3DS all on one code base like it is genuinely awesome and because it's so small it's like you know kind of appealing and when you have less scope you can choose to spend that energy that complexity budget you can put it into polish right and like on a small platform a small idea can shine so okay well we can't solve complexity but we can make things

worse this is actually from augmenting Human intellect uh by angelart in 1962 and it's demonstrating um that you know you can in fact change people's experience um with uh design interventions I said change not improve so you you can we we've made things pretty bad in terms of software development this is the uh my favorite slide always to show this is the uh Cloud native cloud cloud Foundation Cloud native landscape I always get this wrong um this is ostensibly I think 20 trillion worth of companies anyway please memorize all of

this it'll be quiz at the end if you want to make a web application in 2022 I had to zoom out the browser just to fit it all on screen for the fun so I'm going to talk a little bit now about our research which kind of ties back into this because I think it might be interesting um our approach is less the kind of like reboot uh uh model and more of the maybe do a little less with less model and one of our sort of research interests kind of Builds on these sort of tools tools for thought a big part of um what we're interested in

as a research group is not Simplicity versus complexity or decentralization or anything like that but we do find that we have to work in that space because what we want are tools that we have agency over that we have ownership of that are ours and can't be taken and so we call our research there uh local first software and the idea is basically that instead of having to go learn that whole chart of Technology that you know you can't actually do any of that stuff if you just run it on your computer cuz that stuff's all in the

cloud so if you want to build software that works on your computer not only do you not get to use all that stuff you don't have to use all that stuff and so this you know it's sort of like simplification like via amputation so we just cut off most of the cloud and then we build things Lo and so you know we've dabbled in a bunch of different platforms over the years um right now we're building things in the browser but storing everything in like indexdb but one of our kind of core beliefs is that um you know

collaboration is such an important part of um thinking and making and doing that it should be like a really fundamental part of our platforms and so we've been exploring technology that allows you to build software that runs on your computer but then collaborates with other people you know even allowing online offline kind of cuts and um the the model underpinning that is a a data structure called automerge it's sort of like a portable versioned Json like data structure you could think of it as like

get for your data um I I don't I'm happy to talk at length about this stuff uh but I don't really want to Harang you too much on you know sort of our particular kind of like development interests but uh it's really incredible just like how it feels to build software that's fast and simple and runs on your computer if you like me have spent the last you know chunk of your career building cloud services and and you know running things in the sky I had this like really memorable outage where Amazon turned off Us East one dirty

because the generators didn't come on in a hurricane and you know we were sort of like 3 days into some God forsaken like system rebuild from backups of everybody's databases and my cooworker turns to me and he goes I'm fixing computers that don't exist in a data center I've never been to for people I've never met and he just had the like thousand yards stareing his eyes and I was like yeah do you need some more coffee yeah but and so you know like in a sense working on this stuff is almost like

Penance for me because I created all these single points of failure anyway so let's recap a little bit of all of this how do we live our lives in this complicated world right so complexity occurs when our systems have internal interactions right complexity doesn't mean oh there's a lot of stuff it's when all that stuff starts to bump against each other and cause unpredictable outcomes and complexity is also a natural consequence of system incentives if you have a lot of people using a thing and you're listening to what they

need and you're you know like evolving as you learn more you're going to end up with something complex and better tools won't change this right the complexity is a consequence of who we are and the choices we make sure you can you can burn through your budget faster but like ultimately where your project ends up on the complexity scale is more about how much time and how many ideas are invested into it than anything else so we can't beat complexity but we can get beaten by it right and so you know what are our coping strategies well

we can start over we can eradicate dependencies we can cut scope do less right we can simplify our architecture and a really big one is being conscious of and learning to kind of identify when you're getting into these like multiplicator environments right like it once you start porting things to multiple platforms and having to build those like per platform abstractions how do you manage that complexity back down how do you isolate complexity and a big part of success is isolating complexity but I also want to you know

give a shout out to gazing into the abyss and you know you can you can uh go go for it right like Embrace complexity harness it yeah it's a deal with with an elder god and you may accomplish great and terrible things but at a great and terrible price you know that's fine but you when you do this you got to be real careful right and and you want to be really deliberate but deliberate about how and when you uh take on that complexity so I guess in in closing we can't solve complexity but we can build

better software uh or to put it in the the words of cyclist Greg lemand it never gets easier you just go faster uh there and that's all

### Summary

Peter van Hardenberg explores the complexities in software development, emphasizing that simplicity is often lost as systems evolve and scale.

### Highlights

- üß† Complexity vs. Difficulty: Complexity is not merely about difficulty; it arises from interactions within systems.
- üîÑ Happy Path: Initial software versions are simple, but edge cases introduce complexity as requirements grow.
- ‚öñÔ∏è Scale Matters: As user numbers increase, the nature of the problems changes, leading to new complexities.
- üß© Leaky Abstractions: Simplistic interfaces can hide underlying complexity, making it harder to manage performance.
- üèóÔ∏è Homeostasis: Complexity in systems tends to stabilize, often requiring rewrites or new approaches to reset the clock.
- üîÑ Start Fresh: Sometimes, starting new projects can be more advantageous than trying to untangle existing complexity.
- üõ†Ô∏è Tools for Thought: Emphasizing local software reduces reliance on complex cloud systems, simplifying development.

### Key Insights

- üß© **Understanding Complexity**: Complexity arises not from the amount of code but from the interactions within systems. Recognizing this can help developers anticipate challenges better.
- üåê **The Happy Path Fallacy**: Initial simplicity often leads to unexpected complexities as edge cases and requirements multiply. Developers must plan for these scenarios from the start to mitigate future issues.
- üìä **Scaling Challenges**: Software that performs well at a small scale may falter as demand grows. Developers need to rethink their approaches to accommodate larger user bases effectively.
- üíª **Leaky Abstractions**: Interfaces that seem simple may mask underlying complexities, leading to performance issues. Understanding the systems beneath these abstractions is crucial for effective debugging and optimization.
- üîÑ **Complexity Homeostasis**: As systems evolve, they tend to reach a stable complexity level. Recognizing this helps in understanding when to refactor or start anew to avoid excessive technical debt.
- üèóÔ∏è **Starting Anew**: Embracing the idea of starting from scratch can provide a clean slate, allowing developers to build without the burden of previous complexities.
- üõ†Ô∏è **Local First Software**: Prioritizing local development tools reduces cloud dependencies, simplifying the development process and increasing developer agency over their projects.

I'm your AI assistant. Feel free to ask me anything about this note!

Experience the magic of NoteGPT AI Chat right now!

## Why Can't We Make Simple Software? - Peter van Hardenberg